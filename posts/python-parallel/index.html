<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre.min.css><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre-exp.min.css><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre-icons.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/nnfx-dark.min.css><link rel=stylesheet href=https://pro.fontawesome.com/releases/v5.10.0/css/all.css integrity=sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p crossorigin=anonymous><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.83.1"><meta name=viewport content="width=device-width,initial-scale=1"><title>平行化你的 Python 程式 &#183; Ming's Site</title><meta name=description content="在運行程式時，我們常希望善用系統的多核環境平行處理資料以提升計算的效率。然而 Python 的平行化似乎沒有那麼簡單。這篇文章會簡單介紹平行運算的概念、平行化 Python 時會遇到的問題、以及如何解決它們。"><link type=text/css rel=stylesheet href=https://minghsu.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://minghsu.io/css/poole.css><link type=text/css rel=stylesheet href=https://minghsu.io/css/syntax.css><link type=text/css rel=stylesheet href=https://minghsu.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><style>pre,code{white-space:pre;overflow-x:scroll}.hljs{display:inline-block;overflow-x:scroll;padding-right:100%;background:0 0;color:#fff;-webkit-text-size-adjust:none;min-width:2300px}</style><style>@import "https://fonts.googleapis.com/css?family=Open+Sans";body{font-family:open sans,sans-serif}.searchTerm{border-radius:5px;width:100%;border:1px solid #00b4cc;padding:8px 12px}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-96ZZVQWZLF"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-96ZZVQWZLF')</script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/yaml.min.js></script><script>hljs.initHighlightingOnLoad()</script><body><aside class=sidebar><div class=container><div class=sidebar-about><a href=https://minghsu.io/><h1>Ming's Site</h1></a><p class=lead><a href=https://github.com/minghsu0107><i class="fab fa-github"></i></a>&nbsp;&nbsp;<a href=https://linkedin.com/in/hao-ming-hsu-178176181> <i class="fab fa-linkedin"></i></a><br><a href=/about>Hao-Ming Hsu (許浩鳴)</a><br>Learn by Doing.<br><a href=https://github.com/minghsu0107>@minghsu0107</a></p></div><nav><ul class=sidebar-nav><li><a href=/about>About</a></li><li><a href=/categories>Categories</a></li><li><a href=/tags>Tags</a></li></ul></nav><div style="margin:0 auto"><form action=https://minghsu.io/search><input placeholder=search class=searchTerm id=search-query name=s></form></div><br><p>&copy; 2023. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>平行化你的 Python 程式</h1><time datetime=2021-04-14T15:27:23+0800 class=post-date>Wed, Apr 14, 2021 &#183; <span class=read-time>6 min read</span></time><div class=chip><a href=https://minghsu.io/tags/python//>Python</a></div><div class=chip><a href=https://minghsu.io/tags/parallel//>Parallel</a></div><br><br><p>在運行程式時，我們常希望善用系統的多核環境平行處理資料以提升計算的效率。然而 Python 的平行化似乎沒有那麼簡單。這篇文章會簡單介紹平行運算的概念、平行化 Python 時會遇到的問題、以及如何解決它們。</p><p><img src=/static/images/3MDT9fN.png alt></p><h2 id=multiprocessing-vs-multithreading>Multiprocessing vs. Multithreading</h2><p>Multiprocessing 是一種將程式或指令同時跑在<strong>多個平行 process</strong> 的運算模式。當你的工作可以高度平行化時，也就是 subtask 之間是互相獨立的情況下，multiprocessing 就可以利用多核的環境幫助你加速運算。</p><p>說到 multiprocessing 就不得不提到 multithreading。Multithreading 與 multiprocessing 很相似，目標都是要將工作平行化處理，然而在 multithreading 中，多個平行的 thread <strong>共享 heap (動態記憶體空間)、data section (global/staic 變數)、與一些 OS 資源</strong>，如 open files 與 signals。因此若多個 thread 共享某塊 memory 內的資料，那麼程式設計者就必須使用一系列 synchronization 的技巧來預防 dead lock 與 race condition。這是一個很大的主題，在這邊先不深究，以後有機會會寫一篇文章另外講解。</p><h2 id=python-與平行化>Python 與平行化</h2><p>CPython 有一個 GIL (Global Interpreter Lock) 的設計，它保證在任何時刻只會有一個 thread 執行 Python code 以確保 multithreading 下的 thread safety。當<strong>執行一定數量的 code 或是 I/O 被阻塞</strong>時， CPython 為了平衡不同 thread 的執行時間，會強制釋放 GIL 並轉移到其他的 thread 上。</p><p>在 single thread 的情況下 GIL 不會造成嚴重的問題。但是當我們嘗試把工作分佈到多個 thread 上時，GIL 會 CPU-bound 的工作效率低下，這是因為 GIL 限制了多個 thread 的並行。要注意的是，GIL 不會對 IO-bound task 造成影響，這是因為 GIL 在 thread 等待 I/O 時就會被釋放。</p><p>然而在資料處理上，大部分的 task 都還是 CPU-Bound 的，難道 Python 就不能平行話 CPU-bound 的工作了嗎？ 當然不是。我們還有 multiprocessing 可以使用！當我們運行多個 Python 的 process 時，每個 Process 都會有一個它自己的 Python interpreter 與記憶體空間，這解決了上述提到的 GIL 的問題。雖然運行多個 process 的開銷遠比 thread 還要大，但對於 CPU-bound task 來說這樣的 overhead 是可以忽略的。</p><p>接下來會展示如何以 Python 的 <code>multiprocessing</code> 套件實作 worker pool，也就是維護數個運行的 worker，每個 worker 都是一個 process，並將 task 切成數個 subtask 分配給這群 worker。當一個 worker 完成當前工作後，它會去檢查還有沒有尚未被其他 worker 執行的 subtask，若有則拿去執行。</p><p>Worker pool 讓我們能夠節省系統資源的開銷。如果我們每新增一個 subtask 就創建一個 process，不僅 overhead 很大而且也會很快就耗盡系統資源。</p><h2 id=實作-worker-pool>實作 Worker Pool</h2><p>假設 <code>demo</code> 函式是我們希望平行運行的 subtask，它簡單的將兩個整數相加並印出結果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>demo</span>(a: int, b: int):
    <span style=color:#66d9ef>print</span>(f<span style=color:#e6db74>&#39;{a} + {b} = {a+b}&#39;</span>)
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b
</code></pre></div><p>使用當前 cpu 數量做為 pool size 並行處理 <code>demo(0, 0)</code>, <code>demo(1, 1)</code> &mldr; <code>demo(9, 9)</code>。<code>starmap()</code> 方法讓我們傳入需要的參數並阻塞等待所有 subtask 完成，最後在結束時返回所有運行的結果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Pool
<span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> cpu_count

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pool_sync</span>():
    pool_sz <span style=color:#f92672>=</span> cpu_count()
    <span style=color:#66d9ef>with</span> Pool(pool_sz) <span style=color:#66d9ef>as</span> p:
        res <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>starmap(demo, [(i, i) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)])
        p<span style=color:#f92672>.</span>close()
        p<span style=color:#f92672>.</span>join()

    <span style=color:#66d9ef>print</span>(res)
</code></pre></div><p>使用 <code>starmap_async</code> 會馬上返回並回傳一個 callback。我們可以用 <code>callback.get()</code> 來取得所有運行結果：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pool_async</span>():
    pool_sz <span style=color:#f92672>=</span> cpu_count()
    <span style=color:#66d9ef>with</span> Pool(pool_sz) <span style=color:#66d9ef>as</span> p:
        <span style=color:#75715e># returns immediately</span>
        cb <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>starmap_async(demo, [(i, i) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)])
        res <span style=color:#f92672>=</span> cb<span style=color:#f92672>.</span>get()
        p<span style=color:#f92672>.</span>close()
        p<span style=color:#f92672>.</span>join()

    <span style=color:#66d9ef>print</span>(res)
</code></pre></div><p>完整程式碼：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> Pool
<span style=color:#f92672>from</span> multiprocessing <span style=color:#f92672>import</span> cpu_count

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>demo</span>(a: int, b: int):
    <span style=color:#66d9ef>print</span>(f<span style=color:#e6db74>&#39;{a} + {b} = {a+b}&#39;</span>)
    <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pool_sync</span>():
    pool_sz <span style=color:#f92672>=</span> cpu_count()
    <span style=color:#66d9ef>with</span> Pool(pool_sz) <span style=color:#66d9ef>as</span> p:
        res <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>starmap(demo, [(i, i) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)])
        p<span style=color:#f92672>.</span>close()
        p<span style=color:#f92672>.</span>join()

    <span style=color:#66d9ef>print</span>(res)

<span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pool_async</span>():
    pool_sz <span style=color:#f92672>=</span> cpu_count()
    <span style=color:#66d9ef>with</span> Pool(pool_sz) <span style=color:#66d9ef>as</span> p:
        <span style=color:#75715e># returns immediately</span>
        cb <span style=color:#f92672>=</span> p<span style=color:#f92672>.</span>starmap_async(demo, [(i, i) <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>10</span>)])
        res <span style=color:#f92672>=</span> cb<span style=color:#f92672>.</span>get()
        p<span style=color:#f92672>.</span>close()
        p<span style=color:#f92672>.</span>join()

    <span style=color:#66d9ef>print</span>(res)

<span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
    pool_sync()
    pool_async()
</code></pre></div><p>可能的 output：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=color:#ae81ff>0</span> + 0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
<span style=color:#ae81ff>1</span> + 1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>2</span> + 2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
<span style=color:#ae81ff>3</span> + 3 <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
<span style=color:#ae81ff>4</span> + 4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
<span style=color:#ae81ff>5</span> + 5 <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
<span style=color:#ae81ff>7</span> + 7 <span style=color:#f92672>=</span> <span style=color:#ae81ff>14</span>
<span style=color:#ae81ff>6</span> + 6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>8</span> + 8 <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
<span style=color:#ae81ff>9</span> + 9 <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>
<span style=color:#f92672>[</span>0, 2, 4, 6, 8, 10, 12, 14, 16, 18<span style=color:#f92672>]</span>
<span style=color:#ae81ff>0</span> + 0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
<span style=color:#ae81ff>1</span> + 1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
<span style=color:#ae81ff>2</span> + 2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>
<span style=color:#ae81ff>3</span> + 3 <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>
<span style=color:#ae81ff>5</span> + 5 <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>
<span style=color:#ae81ff>4</span> + 4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>
<span style=color:#ae81ff>6</span> + 6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
<span style=color:#ae81ff>9</span> + 9 <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>
<span style=color:#ae81ff>7</span> + 7 <span style=color:#f92672>=</span> <span style=color:#ae81ff>14</span>
<span style=color:#ae81ff>8</span> + 8 <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>
<span style=color:#f92672>[</span>0, 2, 4, 6, 8, 10, 12, 14, 16, 18<span style=color:#f92672>]</span>
</code></pre></div><p>注意到每個 subtask 並不是按照順序而是平行的執行，但最後返回的結果是按照我們輸入給 <code>starmap</code> 或是 <code>starmap_async</code> 的參數順序的。</p><h2 id=總結>總結</h2><p>在資料科學的領域中，我們常常需要從資料庫撈出海量資料、預處理後再做進一步的分析。如果能善用資料平行處理的技巧可以大大提高運算的效率。希望大家看完這篇文章後能更了解平行運算與 GIL 的概念，並且能實際應用在日常的工作中！</p></div><ul></ul><h2>Comments</h2><script src=https://utteranc.es/client.js repo=minghsu0107/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></main></body></html>
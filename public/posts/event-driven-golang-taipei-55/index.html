<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre.min.css><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre-exp.min.css><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre-icons.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai.min.css><link rel=stylesheet href=https://pro.fontawesome.com/releases/v5.10.0/css/all.css integrity=sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p crossorigin=anonymous><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>輕鬆「Go」建事件驅動應用 &#183; Ming's Site</title><meta name=description content><link type=text/css rel=stylesheet href=https://minghsu0107.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://minghsu0107.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://minghsu0107.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://minghsu0107.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script>hljs.initHighlightingOnLoad()</script><body><aside class=sidebar><div class=container><div class=sidebar-about><a href=https://minghsu0107.github.io/><h1>Ming's Site</h1></a><p class=lead><a href=https://github.com/minghsu0107><i class="fab fa-github"></i></a>&nbsp;&nbsp;<a href=https://linkedin.com/in/hao-ming-hsu-178176181> <i class="fab fa-linkedin"></i></a><br><a href=/about>Hao-Ming Hsu (許浩鳴)</a><br>專注於 Golang、後端開發與雲原生技術。<br><a href=https://github.com/minghsu0107>@minghsu0107</a></p></div><nav><ul class=sidebar-nav><li><a href=/about>About</a></li><li><a href=/categories>Categories</a></li><li><a href=/tags>Tags</a></li></ul></nav><p>&copy; 2021. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>輕鬆「Go」建事件驅動應用</h1><time datetime=2021-02-25T23:57:02+0800 class=post-date>Thu, Feb 25, 2021</time><p>這篇文章統整了我在 <a href=https://www.meetup.com/golang-taipei-meetup/events/276423744/>Golang Taipei #55 Meetup</a> 分享的內容。</p><p>Event-driven architecture 在近幾年越來越受關注，它不僅幫助我們解耦服務組件、反轉依賴，更可提高系統的 throughput，大幅提升了擴展性。</p><p>這次主題會講解 Event-driven 的核心概念，簡介幾種常見的分佈式消息系統，並展示如何輕鬆用 Golang 實作 event-driven application，幫助大家能更快理解。</p><script async class=speakerdeck-embed data-slide=3 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><h2 id=什麼是-event>什麼是 Event</h2><p>Event 可以是一個「改變系統狀態」的變化，也可以是陳述當前系統狀態的「事實」，如使用者的點擊、sensor 的資料流、一筆成立的訂單資訊等。而產生 event 的一方叫生產者 (producer)，接收 event 的一方叫消費者 (consumer)。</p><script async class=speakerdeck-embed data-slide=5 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><p>如上圖，event publisher 產生了一個 event 後，數個對此事件有興趣的 consumer 都可以訂閱它。</p><h2 id=事件驅動架構>事件驅動架構</h2><p>主流的架構有兩種：</p><ol><li>Pub/Sub model</li></ol><p>消費者訂閱一到數個事件流，當一個事件產生(被發布)後會被送給有訂閱它的消費者</p><ol start=2><li>Event streaming</li></ol><p>事件被 append 進 log 並存在 event store。不同於 Pub/Sub 模型，Consumer 可以參與任一事件流並從任何一個時間點開始 &ldquo;replay&rdquo;，產生一個 view，這個過程叫做 view generation。相關的應用有 Event sourcing、CQRS (讀寫分離) 等。</p><script async class=speakerdeck-embed data-slide=6 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><p>上圖簡單的描述了一個 event sourcing 的架構。由 end users 產生的各種 event 會被存在 event store，而每個 consumer 各對應到一個 view generation，並寫道 read storage，而外部所有的 query 只會訪問 read storage。這樣讀寫分離的架構讓我們能更有彈性的根據不同場景選擇適合的 DB，比如需要全文檢索的時候就可以考慮使用 ElasticSearch 作為 read storage 等。</p><h2 id=why-事件驅動>Why 事件驅動</h2><ul><li>使用事件來溝通不同服務幫助我們明確建立 Domain event、並且維持程式邊界，進而維持服務自治性。</li><li>解耦系統組件、鬆散依賴。</li><li>事件的異步處理幫助提高系統的 throughput、提高整體架構的擴展性。</li><li>反轉依賴，讓系統更貼近真實業務邏輯關係。</li><li>幫助我們建構 <a href=https://www.reactivemanifesto.org>responsive system</a>：</li></ul><script async class=speakerdeck-embed data-slide=7 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><h2 id=事件驅動與微服務>事件驅動與微服務</h2><script async class=speakerdeck-embed data-slide=8 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><p>從上圖可以看到，微服務之間藉由 event bus (message broker) 使用事件彼此溝通 (pub/sub)，而每個微服務都各自維護一個 database，並訂閱與自身服務相關的事件。由此可以發現，一個微服務可以是生產者、消費者、或是兩者都是。</p><h2 id=注意事項>注意事項</h2><ul><li>使用前需要評估系統對資料一致性的要求：當資料具最終一致性的場境較容易處理</li><li>要小心分散式交易時的資料一致性問題：在分散式的架構下，我們不再能使用單個 DB transaction 確保交易的原子性。當一筆交易分佈在多個服務時確保交易一致性的方法：多階段提交、saga pattern。</li><li>額外的維運成本：相比單體架構，有更多的服務與外部系統要維護、監控</li></ul><script async class=speakerdeck-embed data-slide=9 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><p>小結：<strong>事件驅動並不是 silver bullet，還是要看應用場景選擇最適合的架構</strong>。</p><h2 id=用-golang-實作事件驅動>用 Golang 實作事件驅動</h2><h3 id=watermill>Watermill</h3><ul><li><a href=https://github.com/ThreeDotsLabs/watermill>https://github.com/ThreeDotsLabs/watermill</a></li></ul><script async class=speakerdeck-embed data-slide=16 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><p>Watermill 是一個幫助我們實作 message streaming 的 Golang library，它統一 publish/subscribe 介面，因此可以輕鬆換到不同底層 broker 而不需修改核心程式碼。</p><p>另外，它有著充滿彈性的 API ，讓我們可以掌握 broker-specific 的設定，比如使用 Kafka 時可以直接 override Sarama 的 config，完成更細部的客戶端設定。Watermill 同時也提供開箱即用的 middleware，讓我們不用手刻 Timeout、Retry、Recovery 等諸多功能。值得一提的是，除了 Kafka 或 RabbitMQ 等常見的 broker，watermill 也支持 HTTP 或是 MySQL binlog，因此實用性滿高的。</p><p>Watermill 的核心就是 Pub/Sub 的 interface。它將所有種類的 message broker 都封裝成 Publisher 與 Subscriber 的介面，讓我們的程式碼可以與底層的 client library 解耦：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Publisher</span> <span style=color:#66d9ef>interface</span> {
    <span style=color:#a6e22e>Publish</span>(<span style=color:#a6e22e>topic</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>messages</span> <span style=color:#f92672>...*</span><span style=color:#a6e22e>Message</span>) <span style=color:#66d9ef>error</span>
    <span style=color:#a6e22e>Close</span>() <span style=color:#66d9ef>error</span>
}
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Subscriber</span> <span style=color:#66d9ef>interface</span> {
<span style=color:#a6e22e>Subscribe</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>topic</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>&lt;-</span><span style=color:#66d9ef>chan</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Message</span>, <span style=color:#66d9ef>error</span>)
    <span style=color:#a6e22e>Close</span>() <span style=color:#66d9ef>error</span>
}
</code></pre></div><h3 id=demo>Demo</h3><p>完整程式碼請看<a href=https://github.com/minghsu0107/golang-taipei-watermill-example>這裡</a>。</p><p><img src=https://i.imgur.com/Yt6MIsA.png alt></p><ol><li>有一個 publisher 每三秒向 <code>incoming_topic</code> 發布一個新消息</li><li><code>helloHandler</code> 與 <code>incomingTopicHandler</code> 訂閱了 <code>incoming_topic</code> 這個主題，而 <code>outgoingTopicHandler</code> 則訂閱了 <code>outgoing_topic</code></li><li>當 <code>helloHandler</code> 收到了一個新消息，它會再發布另一個 greeting message 到 <code>outgoing_topic</code></li><li>最後訂閱了 <code>outgoing_topic</code> 的 outgoingTopicHandler 收到了這個 greeting message。</li></ol><p>接著來看看程式碼實作。首先我們建立一個 router，router 負責管理所有的 pub/sub handler，並且可以在 router 上註冊 global 的 middleware：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>AddPlugin</span>(<span style=color:#a6e22e>plugin</span>.<span style=color:#a6e22e>SignalsHandler</span>)
<span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>AddMiddleware</span>(
    <span style=color:#a6e22e>middleware</span>.<span style=color:#a6e22e>CorrelationID</span>,
    <span style=color:#a6e22e>middleware</span>.<span style=color:#a6e22e>Timeout</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span><span style=color:#f92672>*</span><span style=color:#ae81ff>10</span>),
    <span style=color:#a6e22e>middleware</span>.<span style=color:#a6e22e>NewThrottle</span>(<span style=color:#ae81ff>10</span>, <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>).<span style=color:#a6e22e>Middleware</span>,
    <span style=color:#a6e22e>middleware</span>.<span style=color:#a6e22e>Retry</span>{
        <span style=color:#a6e22e>MaxRetries</span>: <span style=color:#ae81ff>5</span>,
        <span style=color:#a6e22e>Logger</span>:     <span style=color:#a6e22e>logger</span>,
    }.<span style=color:#a6e22e>Middleware</span>,
    <span style=color:#a6e22e>middleware</span>.<span style=color:#a6e22e>Recoverer</span>,
)
</code></pre></div><p>這邊展示了一些常用的 middleware，比如 Timeout、Throttle、Retry 與 Recovery 機制等。</p><p>由於我們使用 NATS Streaming 作為底層的 broker，因此我們可以寫一個 NATS Streaming client 的 factory，它會回傳前面所提到的 Publisher 或是 Subscriber：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewNATSPublisher</span>(<span style=color:#a6e22e>logger</span> <span style=color:#a6e22e>watermill</span>.<span style=color:#a6e22e>LoggerAdapter</span>, <span style=color:#a6e22e>clusterID</span>, <span style=color:#a6e22e>natsURL</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>Publisher</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>nats</span>.<span style=color:#a6e22e>NewStreamingPublisher</span>(
        <span style=color:#a6e22e>nats</span>.<span style=color:#a6e22e>StreamingPublisherConfig</span>{
            <span style=color:#a6e22e>ClusterID</span>: <span style=color:#a6e22e>clusterID</span>,
            <span style=color:#a6e22e>ClientID</span>:  <span style=color:#a6e22e>watermill</span>.<span style=color:#a6e22e>NewShortUUID</span>(),
            <span style=color:#a6e22e>StanOptions</span>: []<span style=color:#a6e22e>stan</span>.<span style=color:#a6e22e>Option</span>{
                <span style=color:#a6e22e>stan</span>.<span style=color:#a6e22e>NatsURL</span>(<span style=color:#a6e22e>natsURL</span>),
            },
            <span style=color:#a6e22e>Marshaler</span>: <span style=color:#a6e22e>marshaler</span>,
        },
        <span style=color:#a6e22e>logger</span>,
    )
}
<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewNATSSubscriber</span>(<span style=color:#a6e22e>logger</span> <span style=color:#a6e22e>watermill</span>.<span style=color:#a6e22e>LoggerAdapter</span>, <span style=color:#a6e22e>clusterID</span>, <span style=color:#a6e22e>clientID</span>, <span style=color:#a6e22e>natsURL</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>Subscriber</span>, <span style=color:#66d9ef>error</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>nats</span>.<span style=color:#a6e22e>NewStreamingSubscriber</span>(
        <span style=color:#a6e22e>nats</span>.<span style=color:#a6e22e>StreamingSubscriberConfig</span>{
            <span style=color:#a6e22e>ClusterID</span>: <span style=color:#a6e22e>clusterID</span>,
            <span style=color:#a6e22e>ClientID</span>:  <span style=color:#a6e22e>clientID</span>,
            <span style=color:#a6e22e>StanOptions</span>: []<span style=color:#a6e22e>stan</span>.<span style=color:#a6e22e>Option</span>{
                <span style=color:#a6e22e>stan</span>.<span style=color:#a6e22e>NatsURL</span>(<span style=color:#e6db74>&#34;nats://nats-streaming:4222&#34;</span>),
            },
            <span style=color:#a6e22e>Unmarshaler</span>: <span style=color:#a6e22e>marshaler</span>,
        },
        <span style=color:#a6e22e>logger</span>,
    )
}
</code></pre></div><p>接著我們向 router 註冊 <code>helloHandler</code> 與只有作用在 <code>helloHandler</code> 的 middleware：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>handler</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>AddHandler</span>(
    <span style=color:#e6db74>&#34;hello_handler&#34;</span>,
    <span style=color:#a6e22e>incomingTopic</span>,
    <span style=color:#a6e22e>subscriber</span>,
    <span style=color:#a6e22e>outgoingTopic</span>,
    <span style=color:#a6e22e>publisher</span>,
    <span style=color:#a6e22e>helloHandler</span>{}.<span style=color:#a6e22e>Handler</span>,
)

<span style=color:#a6e22e>handler</span>.<span style=color:#a6e22e>AddMiddleware</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>h</span> <span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>HandlerFunc</span>) <span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>HandlerFunc</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>message</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>Message</span>) ([]<span style=color:#f92672>*</span><span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>Message</span>, <span style=color:#66d9ef>error</span>) {
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\nexecuting hello_handler specific middleware for %s&#34;</span>, <span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>UUID</span>)
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>(<span style=color:#a6e22e>message</span>)
    }
})
</code></pre></div><p>註冊 <code>incomingTopicHandler</code> 與 <code>outgoingTopicHandler</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>AddNoPublisherHandler</span>(
    <span style=color:#a6e22e>incomingTopic</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;_handler&#34;</span>,
    <span style=color:#a6e22e>incomingTopic</span>,
    <span style=color:#a6e22e>subscriber</span>,
    <span style=color:#a6e22e>incomingTopicHandler</span>{}.<span style=color:#a6e22e>HandlerWithoutPublish</span>,
)

<span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>AddNoPublisherHandler</span>(
    <span style=color:#a6e22e>outgoingTopic</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#34;_handler&#34;</span>,
    <span style=color:#a6e22e>outgoingTopic</span>,
    <span style=color:#a6e22e>subscriber</span>,
    <span style=color:#a6e22e>outgoingTopicHandler</span>{}.<span style=color:#a6e22e>HandlerWithoutPublish</span>,
)
</code></pre></div><p>最後在背景每三秒向 <code>incomingTopic</code> 發布訊息，同時啟動 router：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>go</span> <span style=color:#a6e22e>publishMessages</span>(<span style=color:#a6e22e>incomingTopic</span>, <span style=color:#a6e22e>publisher</span>)

<span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>()
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>router</span>.<span style=color:#a6e22e>Run</span>(<span style=color:#a6e22e>ctx</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>publishMessages</span>(<span style=color:#a6e22e>topic</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>publisher</span> <span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>Publisher</span>) {
    <span style=color:#66d9ef>for</span> {
        <span style=color:#a6e22e>msg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>message</span>.<span style=color:#a6e22e>NewMessage</span>(<span style=color:#a6e22e>watermill</span>.<span style=color:#a6e22e>NewUUID</span>(), []byte(<span style=color:#e6db74>&#34;Hello, watermill!&#34;</span>))
        <span style=color:#a6e22e>middleware</span>.<span style=color:#a6e22e>SetCorrelationID</span>(<span style=color:#a6e22e>watermill</span>.<span style=color:#a6e22e>NewUUID</span>(), <span style=color:#a6e22e>msg</span>)

        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;\n\n\nSending message %s, correlation id: %s\n&#34;</span>, <span style=color:#a6e22e>msg</span>.<span style=color:#a6e22e>UUID</span>, <span style=color:#a6e22e>middleware</span>.<span style=color:#a6e22e>MessageCorrelationID</span>(<span style=color:#a6e22e>msg</span>))
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>publisher</span>.<span style=color:#a6e22e>Publish</span>(<span style=color:#a6e22e>topic</span>, <span style=color:#a6e22e>msg</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
            <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
        }
        <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
    }
}
</code></pre></div><p>啟動服務：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>docker-compose up
</code></pre></div><p>若把 <code>WATERMILL_PUBSUB_TYPE</code> 環境變數設為空字串就可以將底層的 broker 換成 GoChannel Pub/Sub，有興趣可以實驗看看，兩者的 output 會是一模一樣的。</p><h2 id=messaging-systems>Messaging Systems</h2><p>前面談到 message broker 可以是各種不同的實作，比如 RabbitMQ 或 Kafka 等。但各種訊息系統有什麼不同呢？這邊會做一個簡單的比較與整理。</p><p>下圖來自我在簡報中做的 Message broker 比較與整理：</p><script async class=speakerdeck-embed data-slide=11 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><p>Kafka 是許多企業的 event streaming 平台首選，這是因爲他的高 throughput、擴展性與可靠性。而 RabbitMQ 實作了 AMQP 協定，它豐富的 routing 機制讓我們可以處理很複雜的資料流。而 NATS Streaming 是三者中最年輕的，它是以 Golang 實作的 CNCF 專案，十分輕快速，部署也相對容易，並且結合了前述兩者的優點。</p><p>舉例來說，NATS Streaming 有以下特性：</p><script async class=speakerdeck-embed data-slide=13 data-id=3579c24fdefe4d62bc1641ea52beacfb data-ratio=1.77777777777778 src=//speakerdeck.com/assets/embed.js></script><p>由上圖可以看到，NATS Streaming 結合了 Kafka 的 ConsumerGroup 特點與 RabbitMQ 的路由 matching 機制，讓我們在開發上有更多選擇的彈性。</p><h2 id=總結>總結</h2><p>事件驅動能夠以貼近真實業務邏輯的方式描述系統架構，並幫助我們解耦服務依賴，提高擴展性，而 Watermill 更使得這一切變的容易實現。</p><p>很高興這次能夠在 Golang Taipei 分享我的一些想法，這次的講者經驗也讓我體會到社群滿滿的熱情與活力！</p><h2 id=reference>Reference</h2><ul><li><a href=https://www.rabbitmq.com>https://www.rabbitmq.com</a></li><li><a href=http://kafka.apache.org>http://kafka.apache.org</a></li><li><a href=https://nats.io>https://nats.io</a></li><li><a href=https://www.redhat.com/en/topics/integration/what-is-event-driven-architecture>https://www.redhat.com/en/topics/integration/what-is-event-driven-architecture</a></li><li><a href=https://arxiv.org/pdf/1912.03715.pdf>https://arxiv.org/pdf/1912.03715.pdf</a></li><li><a href=https://github.com/ThreeDotsLabs/watermill>https://github.com/ThreeDotsLabs/watermill</a></li><li><a href=https://watermill.io/docs/cqrs/#building-a-read-modelwith-the-event-handler>https://watermill.io/docs/cqrs/#building-a-read-modelwith-the-event-handler</a></li></ul></div><h2>Comments</h2><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//minghsu0107.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></main><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','\u003c!-- Global site tag (gtag.js) - Google Analytics --\u003e\n\u003cscript async src=\u0022https://www.googletagmanager.com/gtag/js?id=G-FKDMS72DQV\u0022\u003e\u003c/script\u003e\n\u003cscript\u003e\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag(\u0027js\u0027, new Date());\n\n  gtag(\u0027config\u0027, \u0027G-FKDMS72DQV\u0027);\n\u003c/script\u003e','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>
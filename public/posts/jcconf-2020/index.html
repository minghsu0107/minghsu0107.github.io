<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre.min.css><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre-exp.min.css><link rel=stylesheet href=https://unpkg.com/spectre.css/dist/spectre-icons.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/nnfx-dark.min.css><link rel=stylesheet href=https://pro.fontawesome.com/releases/v5.10.0/css/all.css integrity=sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p crossorigin=anonymous><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.81.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>JCConf 2020 心得 &#183; Ming's Site</title><meta name=description content><link type=text/css rel=stylesheet href=https://minghsu0107.github.io/css/print.css media=print><link type=text/css rel=stylesheet href=https://minghsu0107.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://minghsu0107.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://minghsu0107.github.io/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png></head><style>pre,code{white-space:pre;overflow-x:scroll}.hljs{display:inline-block;overflow-x:scroll;padding-right:100%;background:0 0;color:#fff;-webkit-text-size-adjust:none;min-width:2300px}</style><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/languages/yaml.min.js></script><script>hljs.initHighlightingOnLoad()</script><body><aside class=sidebar><div class=container><div class=sidebar-about><a href=https://minghsu0107.github.io/><h1>Ming's Site</h1></a><p class=lead><a href=https://github.com/minghsu0107><i class="fab fa-github"></i></a>&nbsp;&nbsp;<a href=https://linkedin.com/in/hao-ming-hsu-178176181> <i class="fab fa-linkedin"></i></a><br><a href=/about>Hao-Ming Hsu (許浩鳴)</a><br>Learn by Doing.<br><a href=https://github.com/minghsu0107>@minghsu0107</a></p></div><nav><ul class=sidebar-nav><li><a href=/about>About</a></li><li><a href=/categories>Categories</a></li><li><a href=/tags>Tags</a></li></ul></nav><p>&copy; 2021. All rights reserved.</p></div></aside><main class="content container"><div class=post><h1>JCConf 2020 心得</h1><time datetime=2021-02-24T16:27:23+0800 class=post-date>Wed, Feb 24, 2021 &#183; <span class=read-time>8 min read</span></time><p>以下與大家分享一些這次 JCConf 2020 中我認為值得討論的主題。</p><p>整體來說，滿多議程在推廣 Kotlin 、serverless 與微服務的使用，而大家滿心期待的 Java virtual thread 也已如火如荼的開發中！</p><p><img src=https://i.imgur.com/T6Ib4ws.png alt></p><h2 id=用開源的-mysql-叢集解決大型網路應用的擴充性問題>用開源的 MySQL 叢集解決大型網路應用的擴充性問題</h2><p>現今後端應用的 bottleneck 常常是出現在資料庫上。因此當資料量大到一定程度時，解決資料庫的吞吐瓶頸就會成為一大挑戰。</p><p>常見提高資料庫吞吐量的方式有垂直擴充與水平擴充。垂直擴充是以增加 cpu 與 RAM 等硬體資源為機器升級以提高讀寫效能，而水平擴充則是增加機器並運用分布式架構擴充資料規模，比較常見的方式有主從式讀寫分離架構或資料分片 (sharding) 等。然而對於傳統關聯式資料庫來說，水平擴展比起 NoSQL 困難許多，因為其涉及到了資料的切分或一致性等複雜的問題。</p><h3 id=mysql-叢集>MySQL 叢集</h3><p>為了解決上述的痛點，MySQL 提出了最新的高可用方案，包含了 MySQL Replication、MySQL Group Replication、Shared Disk Based Active/Passive 與 MySQL Cluster：</p><p><img src=https://i.imgur.com/djvJIV2.png alt></p><p>舉例來說，使用 MySQL Cluster 和 MySQL Group Replication多主模式的話，便可用 Connector/J 這個 Java SQL driver 達成負載平衡。而 MySQL Replicatino 與 MySQL Group Replication 的單主模式下則可用 Connector/J 的複製/讀寫分離模式 (只需將 connection object 設為 read-only)。另外，只需一行便可在 Connector/J 的 JDBC 上完成故障移轉。</p><p>因此，當我們的環境有以下的擴充需求時就可以考慮使用 MySQL 叢集：</p><ul><li>高可用不停機</li><li>寫的高吞吐</li><li>高併發連線</li><li>高擴展</li><li>使用簡單和具有彈性</li></ul><p><img src=https://i.imgur.com/7m08DGY.png alt></p><h3 id=mysql--nosql>MySQL & NoSQL</h3><p>Cluster/J 是個另一個 MySQL Cluster 的 driver。它不經 SQL 節點，在 Java程式中透過 JNI 直接呼叫以 C 所開發的NDB API，目的是將 MySQL 以表為主的資料對應到 Java 程式的物件。使用 Cluster/J 便可以 NoSQL 的方式直接取用 MySQL Cluster 上的資料。Cluster/J 以 ClusterJPA 抽象化，支援JPA 而增加可攜性並提供以下特性：</p><ul><li>Persistent classes</li><li>Relationships</li><li>Joins in queries</li><li>Lazy loading</li><li>Table and index creation from object model</li></ul><p><img src=https://i.imgur.com/yi24JJM.png alt></p><p>這是在官網上拿來的例子，假設我們現在要新增一位 employee：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Employee newEmployee <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span><span style=color:#a6e22e>newInstance</span><span style=color:#f92672>(</span>Employee<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>);</span>
</code></pre></div><p><code>session</code> 物件對應一個 cluster/J 與 MySQL 的 connection.
下面的程式碼對應到 <code>insert</code> 操作，有些 ORM 的味道：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>emp<span style=color:#f92672>.</span><span style=color:#a6e22e>setId</span><span style=color:#f92672>(</span>988<span style=color:#f92672>);</span>

newEmployee<span style=color:#f92672>.</span><span style=color:#a6e22e>setFirstName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;John&#34;</span><span style=color:#f92672>);</span>
newEmployee<span style=color:#f92672>.</span><span style=color:#a6e22e>setLastName</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Jones&#34;</span><span style=color:#f92672>);</span>

newEmployee<span style=color:#f92672>.</span><span style=color:#a6e22e>setStarted</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Date<span style=color:#f92672>());</span>
</code></pre></div><p>而這段查詢的程式對應到 <code>SELECT * FROM employee WHERE id = 988</code>：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Employee theEmployee <span style=color:#f92672>=</span> session<span style=color:#f92672>.</span><span style=color:#a6e22e>find</span><span style=color:#f92672>(</span>Employee<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>,</span> 988<span style=color:#f92672>);</span>
</code></pre></div><p>Cluster/J的增刪改的性能非常好，幾乎和 native NDB API 差不多，查詢為一般JDBC的兩倍快：</p><p><img src=https://i.imgur.com/nv0XTbe.png alt></p><h3 id=何時使用>何時使用</h3><p>由於 Cluster/J 直接訪問 Data Node 可達2億 QPS，而 Connector/J 對 SQL Node 則可到每秒250萬個 SQL 指令。因此推薦<strong>複雜的查詢可以透過 SQL 指令查詢，而 Key-Value 的操作則以 Cluster/J 加快操作速度</strong>。而這些都是建立在 MySQL 叢集上的，因此兩種方式都可保有高可用與擴充性。</p><h2 id=rsocket>RSocket</h2><p>RSocket 是個使用 byte stream 的 binary protocol。它支援四種 interaction models：</p><ol><li>request/response (stream of 1)</li><li>request/stream (finite stream of many)</li><li>fire-and-forget (no response)</li><li>channel (bi-directional streams)</li></ol><p>由於另一位也有參加會議的 Allen 已詳細解說了與 Spring Boot 整合的使用方式。我在此補充並分享一些 RSocket 的特點還有與 gRPC (HTTP/2) 的比較，讓大家更清楚為何一些大公司如阿里巴巴與 Facebook 會選擇在 production 中使用 RSocket 作為通訊基礎。</p><ul><li><strong>輕量</strong>：RSocket 的四個 interactive model 被規範在 RSocket 協定內，而 gRPC 則是藉由 HTTP/2 Stream 傳輸這些 RPC 的資訊，因此 gRPC 傳輸的 overhead 會比較大。</li><li><strong>彈性</strong>：RSocket 在資料的傳輸上更具有彈性，它所需要的只是一個 duplex connection，不像 gRPC 需要事先定義好 protobuf 並且只能使用 protobuf 有定義好的 procudure。另外，gRPC 需要 code generation，但 RSocket 提供開發者更多選擇：喜歡 RPC style 的人可以使用 RSocket-RPC，希望與 Spring 整合的話也可以使用 Spring Messaging，當然直接操作 RSocket 也完全沒問題。</li><li><strong>Session 複用</strong>：RSocket 可以在多次連線之間恢復 long-lived streams。這使的 RSocket 特別適合 mobile 與 server 端的溝通場景。</li><li><strong>Back-pressure</strong>：RSocket 實作了 reactive streams 並支援異步 back-pressure (消費者需要多少，生產者就生產多少)，這樣的 application-level flow control 是基於 HTTP/2 的 gRPC 無法做到的。</li><li><strong>既是 client 也是 server</strong>：RSocket 在連線建立後 server 與 client 都能成為 requester 與 responder。換句話說 RSocket 是 fully duplex 的，client 與 server 都能在同個連線下發出和接受請求。相較之下 gRPC 是標準的 client-server 模型，因此 server 端無法向 client 發出請求。</li><li><strong>瀏覽器支援</strong>：gRPC 在瀏覽器中沒有直接支援，需要額外的函式庫且提高了維護的複雜度。而 RSocket 可以藉由 Websocket 在瀏覽器直接運作，我們只需要開啟一個接受 Websocket 連線的 RSocket instance 即可。</li></ul><p>總結來說，RSocket 為 reactive programming 與 event driven 架構打下了可靠的基礎。它為我們帶來嶄新的服務通訊方式，而其輕量的特性也使我們能更輕鬆擴展 real-time 的 application。</p><h2 id=其他議程>其他議程</h2><ul><li><strong>街口支付的唯服務之路</strong>：分享了街口支付如何將高耦合的單體架構重構成領域服務邊界明確的微服務：<ol><li>定義業務領域 (Business Domain) - 找出並定義所有商業行為所包含的 domain knowledge，與該領域的專業人討論再進行業務切分。</li><li>明確領域服務邊界 - 強調 Conway&rsquo;s Law，系統架構即是公司組織的反映 。</li><li>重構與持續優化</li></ol></li><li><strong>快來一起認識 Helm 吧！</strong>：介紹了 Helm 這個 Kubernetes 的套件管理工具，並現場使用 <a href=https://github.com/k0sproject/k0s>k0s</a> + Docker-Compose 實作。詳細內容請看 <a href=https://github.com/CookieTsai/jcconf-helm-demo>Github</a>。</li></ul><h2 id=總結>總結</h2><p>第一次參加 JCConf 這個 Java 年度盛會覺得收穫很多。看到了許多很有料的講者，也深刻的體會到了 Java 社群源源不絕的熱忱與活力。中場休息時間在攤位上也聽到許多新鮮有趣的 sharing。熱愛 Java 跟收集貼紙的人絕對不能錯過！</p><h2 id=reference>Reference</h2><ul><li><a href="https://drive.google.com/file/d/1CBiHgP2aGYG45gvYADBzHCtOUapMqan2/view?fbclid=IwAR0BAo5Q3N-aid1xcWYzuJYo-yLe_s7uk6fZ9dzKkF2T3KL5NM9Jrl4xlcY">MySQL Cluster Slides, JCConf 2020</a></li><li><a href=https://medium.com/netifi/differences-between-grpc-and-rsocket-e736c954e60>Differences between gRPC and RSocket - by Robert B Roeser</a></li><li><a href=https://github.com/k0sproject/k0s>k0s</a></li><li><a href=https://github.com/CookieTsai/jcconf-helm-demo>Helm Demo, JCConf 2020</a></li></ul></div><h2>Comments</h2><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//minghsu0107.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></main><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','\u003cscript async src=\u0022https://www.googletagmanager.com/gtag/js?id=G-96ZZVQWZLF\u0022\u003e\u003c/script\u003e\u003cscript\u003ewindow.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag(\u0027js\u0027, new Date());gtag(\u0027config\u0027, \u0027G-96ZZVQWZLF\u0027);\u003c/script\u003e','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>